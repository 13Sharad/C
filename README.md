# AlgoGenesis: C Algorithms üìò

Welcome to the **AlgoGenesis** collection of algorithms implemented in the **C programming language**. This repository aims to provide a centralized, well-documented source of algorithms that can help both beginners and advanced developers in understanding and solving algorithmic problems efficiently.

---

## üìö Table of Contents

- [Sorting Algorithms](#sorting-algorithms)
- [Searching Algorithms](#searching-algorithms)
- [Recursion](#recursion)
- [Dynamic Programming](#dynamic-programming)
- [Greedy Algorithms](#greedy-algorithms)
- [Graph Algorithms](#graph-algorithms)
- [Mathematical Algorithms](#mathematical-algorithms)
- [String Algorithms](#string-algorithms)

---

## üåÄ Sorting Algorithms

1. **Bubble Sort** - [bubble_sort.c](path-to-file/bubble_sort.c)
2. **Selection Sort** - [selection_sort.c](path-to-file/selection_sort.c)
3. **Insertion Sort** - [insertion_sort.c](path-to-file/insertion_sort.c)
4. **Merge Sort** - [merge_sort.c](path-to-file/merge_sort.c)
5. **Quick Sort** - [quick_sort.c](path-to-file/quick_sort.c)
6. **Heap Sort** - [heap_sort.c](path-to-file/heap_sort.c)
7. **Radix Sort** - [radix_sort.c](path-to-file/radix_sort.c)

---

## üîç Searching Algorithms

1. **Linear Search** - [linear_search.c](path-to-file/linear_search.c)
2. **Binary Search** - [binary_search.c](path-to-file/binary_search.c)
3. **Jump Search** - [jump_search.c](path-to-file/jump_search.c)
4. **Interpolation Search** - [interpolation_search.c](path-to-file/interpolation_search.c)
5. **Exponential Search** - [exponential_search.c](path-to-file/exponential_search.c)

---

## üîÅ Recursion

1. **Fibonacci Sequence** - [fibonacci.c](path-to-file/fibonacci.c)
2. **Factorial** - [factorial.c](path-to-file/factorial.c)
3. **Towers of Hanoi** - [towers_of_hanoi.c](path-to-file/towers_of_hanoi.c)
4. **Greatest Common Divisor (GCD)** - [gcd.c](path-to-file/gcd.c)
5. **Permutations** - [permutations.c](path-to-file/permutations.c)

---

## üßÆ Dynamic Programming

1. **Knapsack Problem** - [knapsack.c](path-to-file/knapsack.c)
2. **Longest Common Subsequence (LCS)** - [lcs.c](path-to-file/lcs.c)
3. **Fibonacci (Memoization)** - [fibonacci_memoization.c](path-to-file/fibonacci_memoization.c)
4. **Longest Increasing Subsequence** - [longest_increasing_subsequence.c](path-to-file/longest_increasing_subsequence.c)

---

## üí° Greedy Algorithms

1. **Activity Selection Problem** - [activity_selection.c](path-to-file/activity_selection.c)
2. **Huffman Coding** - [huffman_coding.c](path-to-file/huffman_coding.c)
3. **Prim's Minimum Spanning Tree** - [prims_mst.c](path-to-file/prims_mst.c)
4. **Kruskal's Minimum Spanning Tree** - [kruskals_mst.c](path-to-file/kruskals_mst.c)

---

## üåê Graph Algorithms

1. **Breadth-First Search (BFS)** - [bfs.c](path-to-file/bfs.c)
2. **Depth-First Search (DFS)** - [dfs.c](path-to-file/dfs.c)
3. **Dijkstra's Algorithm** - [dijkstra.c](path-to-file/dijkstra.c)
4. **Bellman-Ford Algorithm** - [bellman_ford.c](path-to-file/bellman_ford.c)
5. **Floyd-Warshall Algorithm** - [floyd_warshall.c](path-to-file/floyd_warshall.c)

---

## üî¢ Mathematical Algorithms

1. **Prime Number Check** - [prime_check.c](path-to-file/prime_check.c)
2. **Sieve of Eratosthenes** - [sieve_of_eratosthenes.c](path-to-file/sieve_of_eratosthenes.c)
3. **Euclidean Algorithm (GCD)** - [euclidean_gcd.c](path-to-file/euclidean_gcd.c)
4. **Modular Exponentiation** - [modular_exponentiation.c](path-to-file/modular_exponentiation.c)

---

## ‚úÇÔ∏è String Algorithms

1. **Palindrome Check** - [palindrome_check.c](path-to-file/palindrome_check.c)
2. **String Reversal** - [string_reversal.c](path-to-file/string_reversal.c)
3. **Pattern Matching (Naive)** - [pattern_matching_naive.c](path-to-file/pattern_matching_naive.c)
4. **Knuth-Morris-Pratt (KMP)** - [kmp.c](path-to-file/kmp.c)
5. **Rabin-Karp Algorithm** - [rabin_karp.c](path-to-file/rabin_karp.c)

---

## ü§ù How to Contribute

We are open to contributions! To contribute to this repository, please follow the steps below:

1. Fork the repository.
2. Create a new branch for your algorithm (e.g., `feature/algorithm-name`).
3. Write clear and concise code with comments explaining key parts.
4. Test your code thoroughly.
5. Submit a pull request with a clear description of the algorithm added.

---

## üìú License

This repository is licensed under the MIT License. Feel free to use the code as per the terms of the [LICENSE](LICENSE) file.

---

## ‚≠ê Show your support

If you find this repository helpful, please consider giving it a star ‚≠ê to help others discover it!

